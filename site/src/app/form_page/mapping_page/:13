use std::collections::HashMap;

use yew::components::Select;
use yew::format::Json;
use yew::prelude::*;
use yew::services::fetch::{FetchService, FetchTask, Response, Request};

use crate::auth_agent;
use crate::types::SchemaInfo;
use crate::error::Error;

#[derive(Clone, Default, PartialEq, Serialize)]
pub struct Mapping {
    url: String,
    field_mappings: HashMap<String, String>,
}

#[derive(Default)]
struct State {
    mapping: Mapping,
    schemas: Vec<SchemaInfo>,
    selected_schema: Option<SchemaInfo>
}

pub enum Msg {
    OnChange,
    FetchSuccess(Vec<SchemaInfo>),
    FetchFailure(Error),
    SelectSchema(SchemaInfo),
    AddMapping(String, String),
}

#[derive(Clone, PartialEq, Properties)]
pub struct Props {
    #[props(required)]
    pub onchange: Callback<Mapping>,
    #[props(required)]
    pub mapping: Mapping,
}

pub struct MappingItem {
    state: State,
    link: ComponentLink<Self>,
    onchange: Callback<Mapping>,
    fetch: auth_agent::Schema,
    task: Option<FetchTask>,
}

// The format of our schema so that we may read the field names
#[derive(Clone, PartialEq, Deserialize)]
struct json_schema_form {
    properties: HashMap<String, field_properties>,
}

#[derive(Clone, PartialEq, Deserialize)]
struct field_properties {
    type: String,
}


impl ToString for SchemaInfo {
    fn to_string(&self) -> String {
        format!("{}", self.id)
    }
}

impl Component for MappingItem {
    type Message = Msg;
    type Properties = Props;

    fn create(props: Self::Properties, link: ComponentLink<Self>) -> Self {
        // Attempt to fetch schemas
        let mut fetch = auth_agent::Schema::new();
        let task = fetch.get_all(link.callback(|response: Result<Vec<SchemaInfo>, Error>| {
            match response {
                Ok(list) => Msg::FetchSuccess(list),
                Err(err) => Msg::FetchFailure(err),
            }
        }));

        let state = State {
            mapping: props.mapping,
            schemas: Vec::new(),
            selected_schema: None,
        };

        MappingItem { 
            state: state,
            link,
            onchange: props.onchange,
            fetch: fetch,
            task: Some(task),
        }
    }

    fn update(&mut self, msg: Self::Message) -> ShouldRender {
        match msg {
            Msg::OnChange => {
                self.onchange.emit(self.state.mapping.clone());
                true
            }
            Msg::FetchSuccess(data) => {
                debug!("Success - Schema");
                self.state.schemas = data;
                self.task = None;
                true
            }
            Msg::FetchFailure(error) => {
                self.task = None;
                // TODO: Respond to this
                error!("error: {}", error);
                true
            }
            Msg::SelectSchema(schema_info) => {
                self.state.selected_schema = Some(schema_info);
                // TODO: Create the full url endpoint (for now, use the relative one)
                let url = format!("/api/schemas/{}", schema_info.id);

                // Add the fields we can map
                let field_mappings = HashMap::new();

                self.state.mapping.url = url;
                self.state.mapping.field_mappings = field_mappings;
                self.link.send_message(Msg::OnChange);
                
                true
            }
            Msg::AddMapping(to_field, from_field) => {
                // TODO: Validate types ?
                self.link.send_message(Msg::OnChange);
                true
            }
            OnDrop(DragDropEvent),
            OnDragover(DragOverEvent),
            Msg::OnDrop(event) => {
                event.prevent_default();


                true
            }
            Msg::OnDragover(event) => {
                // Prevent default to allow dropping here
                event.prevent_default();
                false
            }
            _ => false
        }
    }

    fn view(&self) -> Html {
        let schema_selection = html! { 
            <Select<SchemaInfo> options=&self.state.schemas onchange=self.link.callback(|schema| Msg::SelectSchema(schema)) />
        };
        
        // Build a list of the fields in the schema
        let field_display = match self.state.selected_schema {
            Some(schema_info) => {
                let form = schema_info.data;

                html! {

                }
            }
            None => html! {}
        }

        let field_entry = html! {
            <table class="table">
                <thead>
                    <tr>
                        <th>{"name"}</th>
                        <th>{"type"}</th>
                        <th>{"form field to map"}</th>
                    </tr>
                </thead>
            </table>
        };

        html! {
            <div>
                <label class="label">{"Schema to map to:"}</label>
                {schema_selection}
            </div>
        }
    }
}

